# -*- coding: utf-8 -*-
"""Submission_MLT_Hubbal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWJXRzh48u0sh1kG1U2iOqb80D1m_6aX

# Anime Recommendation System

## Data Collection

Import Library
"""

from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score
import re

"""Download Dataset"""

!pip install -q kaggle

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d bhavyadhingra00020/top-anime-dataset-2024

!unzip /content/top-anime-dataset-2024.zip

df = pd.read_csv('/content/Top_Anime_data.csv')

"""## Data Understanding"""

df.head()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

for i, (nama_kolom, jumlah) in enumerate(df.count().items(), 1):
    print(f"Kolom {i:2d}: {nama_kolom} - Berjumlah:  {jumlah}")

df.info()

"""### Ringkasan Struktur DataFrame

Terdapat total **22 kolom** dalam dataframe.
- Terdapat **1 kolom** dengan tipe data `float64`, yang merupakan fitur **numerik**:
  - `Score`
- Terdapat **3 kolom** dengan tipe data `int64`, yang juga merupakan fitur **numerik**:
  - `Popularity`, `Rank`, `Members`
- Terdapat **18 kolom** dengan tipe data `object`, yang kemungkinan besar merupakan fitur **kategoris**:
  - `Description`, `Synonyms`, `Japanese`, `English`, `Type`, `Episodes`, `Status`, `Aired`, `Premiered`, `Broadcast`, `Producers`, `Licensors`, `Studios`, `Source`, `Genres`, `Demographic`, `Duration`, `Rating`

**Pilihan Fitur untuk Content-Based Filtering**

Fitur utama yang digunakan:
- `Genres`: Merekomendasikan anime dengan genre serupa.
- `Type`: Membantu menyarankan tipe anime yang sama (TV, Movie, dll).
- `Studios`: Mengarahkan pada anime dengan gaya/kualitas serupa dari studio yang sama.

**Alasan**:  
Fitur-fitur ini cukup, relevan, dan efisien untuk membangun model rekomendasi yang akurat dan mudah diimplementasikan.
"""

df.duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""## Exploratory Data Analysis

### Deskripsi Variabel
"""

df.columns

"""**Penjelasan Kolom Dataframe**

Kolom datasets anime memiliki informasi berikut:

* **`Score`:** Skor atau rating yang diberikan kepada anime.
* **`Popularity`:** Peringkat popularitas anime.
* **`Rank`:** Peringkat anime berdasarkan kriteria tertentu.
* **`Members`:** Jumlah anggota yang telah menambahkan anime ke daftar mereka di platform.
* **`Description`:** Deskripsi singkat atau ringkasan plot anime.
* **`Synonyms`:** Judul alternatif atau sinonim dari anime.
* **`Japanese`:** Judul anime dalam bahasa Jepang.
* **`English`:** Judul anime dalam bahasa Inggris.
* **`Type`:** Jenis anime (misalnya, TV Series, Movie, OVA, dll.).
* **`Episodes`:** Jumlah episode dalam anime.
* **`Status`:** Status anime (misalnya, ongoing, completed).
* **`Aired`:** Tanggal penayangan anime.
* **`Premiered`:** Musim dan tahun penayangan perdana anime.
* **`Broadcast`:** Informasi tentang siaran anime.
* **`Producers`:** Perusahaan produksi atau produser anime.
* **`Licensors`:** Pihak yang memiliki lisensi anime (misalnya, platform streaming).
* **`Studios`:** Studio animasi yang mengerjakan anime.
* **`Source`:** Sumber materi anime (misalnya, manga, light novel, original).
* **`Genres`:** Genre anime, dipisahkan dengan koma (misalnya, Action, Comedy, Drama).
* **`Demographic`:** Demografi target anime (misalnya, Shonen, Shojo).
* **`Duration`:** Durasi setiap episode anime.
* **`Rating`:** Batasan usia untuk menonton anime.

### Visualisasi
"""

ona = df.loc[df['Type'] == 'ONA'].shape[0]
tv = df.loc[df['Type'] == 'TV'].shape[0]
movie = df.loc[df['Type'] == 'Movie'].shape[0]
music = df.loc[df['Type'] == 'Music'].shape[0]
special = df.loc[df['Type'] == 'Special'].shape[0]
ova = df.loc[df['Type'] == 'OVA'].shape[0]

labels = ['ONA', 'TV', 'Movie', 'Music', 'Special', 'OVA']
colors = ['#81F4E1', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B']

plt.figure(figsize=(10, 7))
plt.title('Distribusi Kategori Anime')
plt.pie([ona, tv, movie, music, special, ova],
        labels=labels,
        colors=colors,
        autopct='%.2f%%',
        textprops={'color': 'black'})

plt.show()

plt.figure(figsize=(10, 6))
plt.hist(df['Score'],
         bins=20,
         color='#56CBF9',
         edgecolor='#0B4F6C',
         alpha=0.8)
plt.xlabel('Skor Anime', fontsize=12)
plt.ylabel('Jumlah Anime', fontsize=12)
plt.title('Distribusi Skor Anime (Skala 1-10)', fontsize=14, pad=20)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

df.describe().T

df.sort_values(by='Members', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Members']].sort_values(by='Members', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B', '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Members'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Jumlah Members", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

df.sort_values(by='Score', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Score']].sort_values(by='Score', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B',
          '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Score'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Skor", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x='Score', y='Members', data=df, alpha=0.6, color='#87255B')
plt.title('Skor vs. Popularitas', fontsize=14)
plt.xlabel('Skor', fontsize=12)
plt.ylabel('Jumlah Members', fontsize=12)
plt.show()

# Ekstrak durasi dalam menit (contoh: '24 min per ep' -> 24)
df['Duration_min'] = df['Duration'].str.extract('(\d+)').astype(float)

plt.figure(figsize=(10, 6))
sns.boxplot(x='Duration_min', data=df, color='#81F4E1')
plt.title('Distribusi Durasi Episode', fontsize=14)
plt.xlabel('Durasi (menit)', fontsize=12)
plt.show()

top_studios = df['Studios'].value_counts().head(10)

plt.figure(figsize=(12, 6))
top_studios.plot(kind='bar', color='#C57B57')
plt.title('Top 10 Studio Anime Berdasarkan Jumlah Produksi', fontsize=14)
plt.xlabel('Studio', fontsize=12)
plt.ylabel('Jumlah Anime', fontsize=12)
plt.xticks(rotation=45)
plt.show()

# Hitung frekuensi genre
all_genres = df['Genres'].str.split(', ').explode()
genre_counts = all_genres.value_counts().head(10)

# Plot
plt.figure(figsize=(12, 6))
genre_counts.plot(kind='barh', color='#C57B57')
plt.title('Top 10 Genre Anime', fontsize=14)
plt.xlabel('Jumlah Anime')
plt.gca().invert_yaxis()
plt.show()

"""## Data Preparation"""

def clean_anime_title(text):
    if pd.isna(text):
        return ""

    text = re.sub(r"https?://\S+|www\.\S+", "", text)

    text = re.sub(r"[^a-zA-Z0-9'\- ]", "", text)

    text = re.sub(r"\s+", " ", text).strip()

    return text
df['English_clean'] = df['English'].apply(clean_anime_title)

def clean_genres(genre_text):
    if pd.isna(genre_text):
        return ""

    raw_genres = genre_text.split(',')
    cleaned_genres = set()

    for genre in raw_genres:
        genre = genre.strip()
        half = len(genre) // 2

        if len(genre) % 2 == 0 and genre[:half].lower() == genre[half:].lower():
            genre = genre[:half]

        cleaned_genres.add(genre.lower())

    return ", ".join(sorted(cleaned_genres))

df['Genres_clean'] = df['Genres'].apply(clean_genres)

def clean_studios(studio_str):
    if pd.isna(studio_str):
        return ""

    studios = [s.strip().lower() for s in studio_str.split(",") if s.strip()]
    return ", ".join(sorted(set(studios)))

df["Studios_clean"] = df["Studios"].apply(clean_studios)

print("Before:", df['Genres'].iloc[0])
print("After:", df['Genres_clean'].iloc[0])

print("Before:", df['English'].iloc[0])
print("After:", df['English_clean'].iloc[0])

print("Before:", df['Studios'].iloc[0])
print("After:", df['Studios_clean'].iloc[0])

print(df[['English', 'English_clean']].sample(3))
print(df[['Genres', 'Genres_clean']].sample(3))
print(df[['Studios', 'Studios_clean']].sample(3))

df

df.astype(str).duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""Terdapat *Missing value* pada kolom `sypnopsis, Japanese, English, Premiered, Broadcast, Genres dan Demographic`"""

df = df.dropna()

"""Menghapus data *Missing value*"""

df.isnull().sum()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

df.describe().T

"""Fungsi `describe()` memberikan informasi statistik pada masing-masing kolom, antara lain:

- `Count` adalah jumlah sampel pada data.
- `Mean` adalah nilai rata-rata.
- `Std` adalah standar deviasi.
- `Min` yaitu nilai minimum setiap kolom.
- `25%` adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
- `50%` adalah kuartil kedua, atau biasa juga disebut median (nilai tengah). - 75% adalah kuartil ketiga.
- `Max` adalah nilai maksimum.

## Model Development
"""

df

data = df.drop(columns=[
    'Score',
    'Popularity',
    'Rank',
    'Members',
    'Description',
    'Synonyms',
    'Japanese',
    'English',
    'Genres',
    'Episodes',
    'Status',
    'Aired',
    'Premiered',
    'Broadcast',
    'Producers',
    'Licensors',
    'Source',
    'Duration',
    'Demographic',
    'Studios'
])

"""Mengahapus kolom yang tidak dibutuhkan pada model kali ini."""

data

"""### Model Content Based Filtering (dengan Filter Genres)"""

tfid = TfidfVectorizer()
tfid.fit(data['Genres_clean'])

tfid.get_feature_names_out()

tfidf_matrix = tfid.fit_transform(data['Genres_clean'])

tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfid.get_feature_names_out(),
    index=data.Genres_clean
).sample(22, axis=1).sample(10, axis=0)

"""Output `matriks tf-idf` di atas menunjukkan hubungan antara nama anime terhadap kategori yang dipilih. Matriks ini menunjukkan seberapa besar korelasi antara Anime terhadap kategori yang dipilih."""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(cosine_sim, index=data['English_clean'], columns=data['English_clean'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(5, axis=0)

def anime_recommendations(anime_name, similarity_data=cosine_sim_df, items=data[['English_clean','Genres_clean']], k=5):

    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

data[data.English_clean.eq('One Piece')]

anime_recommendations('One Piece')

"""### Evaluation Model TF-IDF"""

def evaluate_tfidf_genre_similarity(anime_name: str, top_k: int = 5):
    """Evaluasi kesamaan genre untuk rekomendasi model TF-IDF"""
    try:
        # Dapatkan rekomendasi
        recommendations = anime_recommendations(anime_name, k=top_k)

        if recommendations.empty:
            return f"⚠️ Tidak ada rekomendasi untuk '{anime_name}'"

        # Ambil genre asli
        original_genres = set(data.loc[data['English_clean'] == anime_name, 'Genres_clean'].iloc[0].lower().split(', '))

        # Hitung similarity score
        similarity_scores = []
        for _, row in recommendations.iterrows():
            rec_genres = set(row['Genres_clean'].lower().split(', '))
            intersection = original_genres & rec_genres
            similarity = len(intersection)/len(original_genres) if original_genres else 0
            similarity_scores.append(round(similarity * 100, 2))

        recommendations['Genre Similarity (%)'] = similarity_scores
        mean_score = round(np.mean(similarity_scores), 2)

        print(f"🎯 Hasil evaluasi untuk '{anime_name}':")
        print(f"📊 Rata-rata kesamaan genre: {mean_score}%")
        return recommendations

    except KeyError:
        return f"❌ Anime '{anime_name}' tidak ditemukan"

def batch_evaluate_tfidf(sample_size=10, top_k=5):
    """Evaluasi batch untuk sampel acak"""
    sampled_anime = data.sample(sample_size, random_state=42)['English_clean']
    total_scores = []

    print("\n🔬 Evaluasi Batch Model TF-IDF 🔬")
    print(f"📋 Jumlah sampel: {sample_size}")
    print("===================================\n")

    for anime in sampled_anime:
        result = evaluate_tfidf_genre_similarity(anime, top_k)
        if isinstance(result, pd.DataFrame):
            avg_score = result['Genre Similarity (%)'].mean()
            total_scores.append(avg_score)
            print(f"▸ {anime}: {avg_score}%")

    overall_score = round(np.mean(total_scores), 2)
    print(f"\n📈 Skor keseluruhan: {overall_score}%")
    return overall_score

def visualize_tfidf_performance(sample_size=10, top_k=5):
    """Visualisasi hasil evaluasi"""
    sampled_anime = data.sample(sample_size, random_state=42)['English_clean']
    scores = []
    names = []

    for anime in sampled_anime:
        result = evaluate_tfidf_genre_similarity(anime, top_k)
        if isinstance(result, pd.DataFrame):
            avg_score = result['Genre Similarity (%)'].mean()
            scores.append(avg_score)
            names.append(anime)

    plt.figure(figsize=(12,8))
    plt.barh(names, scores, color='#FF6F61')
    plt.title('🎯 Performa Model TF-IDF (Kesamaan Genre)', pad=20)
    plt.xlabel('Skor Kesamaan (%)')
    plt.ylabel('Anime')
    plt.xlim(0, 100)
    plt.gca().invert_yaxis()

    # Tambah label nilai
    for i, v in enumerate(scores):
        plt.text(v + 1, i, f"{v}%", color='black', ha='left', va='center')

    plt.grid(axis='x', alpha=0.3)
    plt.tight_layout()
    plt.show()

# Contoh penggunaan
evaluate_tfidf_genre_similarity("One Piece")
batch_evaluate_tfidf()
visualize_tfidf_performance()

"""Sistem telah berhasil merekomendasikan top 5 persen anime yang mirip dengan *One Piece*, yaitu beberapa film dan seri dari *One Piece* itu sendiri. Jadi, jika pengguna menyukai *One Piece*, maka sistem dapat merekomendasikan seri atau movie *One Piece* lainnya.

### Model K-Nearest Neighbor
"""

animedf_name = pd.DataFrame({'English_clean': data['English_clean']})
animedf_name.head()

data.set_index('English_clean',inplace=True)

data_n = data[['Genres_clean', 'Type', 'Studios_clean']]

data_features = pd.get_dummies(data_n[['Type', 'Studios_clean']])
data_features.index = data.index

model = NearestNeighbors(metric='euclidean')
model.fit(data_features)

"""### Evaluation Model KNN"""

def recommend(anime_name: str, top_k: int = 5):
    if anime_name not in data_features.index:
        return f"❌ Anime '{anime_name}' tidak ditemukan dalam data."

    distances, indices = model.kneighbors(data_features.loc[[anime_name]], n_neighbors=top_k + 1)

    recommendations = []
    for idx, dist in zip(indices[0][1:], distances[0][1:]):  # Skip anime itu sendiri
        recommendations.append({
            "Anime Name": data_features.index[idx],
            "Distance": dist,
            "Similarity Score": f"{round(100 - dist, 2)}%"
        })

    return pd.DataFrame(recommendations)

# Fungsi Evaluasi Genre Similarity
def evaluate_genre_similarity(anime_name: str, top_k: int = 5):
    result = recommend(anime_name, top_k=top_k)

    if isinstance(result, str):
        return result

    original_genres = set(str(data.loc[anime_name, 'Genres_clean']).lower().split())

    genre_similarities = []
    for rec_name in result['Anime Name']:
        rec_genres = set(str(data.loc[rec_name, 'Genres_clean']).lower().split())
        intersection = original_genres & rec_genres
        similarity_score = len(intersection) / len(original_genres) if original_genres else 0
        genre_similarities.append(round(similarity_score * 100, 2))

    result['Genre Similarity (%)'] = genre_similarities
    mean_similarity = round(np.mean(genre_similarities), 2)

    print(f"📊 Rata-rata genre similarity untuk '{anime_name}' adalah {mean_similarity}%")
    return result

evaluate_genre_similarity("One Piece", top_k=5)

def batch_genre_similarity_evaluation(sample_size=10, top_k=5):
    sampled_anime = data_features.sample(n=sample_size, random_state=42).index
    similarity_scores = []

    print(f"🎯 Evaluasi {sample_size} anime secara acak:\n")

    for anime_name in sampled_anime:
        print(f"🔍 {anime_name}")
        result = recommend(anime_name, top_k=top_k)

        if isinstance(result, str):
            print(result)
            continue

        original_genres = set(str(data.loc[anime_name, 'Genres_clean']).lower().split())
        scores = []
        for rec_name in result['Anime Name']:
            rec_genres = set(str(data.loc[rec_name, 'Genres_clean']).lower().split())
            intersection = original_genres & rec_genres
            similarity_score = len(intersection) / len(original_genres) if original_genres else 0
            scores.append(similarity_score)

        avg_score = round(np.mean(scores) * 100, 2)
        print(f"   ⮑ Rata-rata genre similarity: {avg_score}%\n")
        similarity_scores.append(avg_score)

    overall_score = round(np.mean(similarity_scores), 2)
    print(f"📈 Rata-rata genre similarity keseluruhan: {overall_score}%")
    return overall_score

batch_genre_similarity_evaluation(sample_size=10, top_k=5)

def batch_genre_similarity_plot(sample_size=10, top_k=5):
    sampled_anime = data_features.sample(n=sample_size, random_state=42).index
    anime_names = []
    average_scores = []

    for anime_name in sampled_anime:
        result = recommend(anime_name, top_k=top_k)
        if isinstance(result, str):
            continue

        original_genres = set(str(data.loc[anime_name, 'Genres_clean']).lower().split())
        scores = []
        for rec_name in result['Anime Name']:
            rec_genres = set(str(data.loc[rec_name, 'Genres_clean']).lower().split())
            intersection = original_genres & rec_genres
            similarity_score = len(intersection) / len(original_genres) if original_genres else 0
            scores.append(similarity_score)

        avg_score = round(np.mean(scores) * 100, 2)
        anime_names.append(anime_name)
        average_scores.append(avg_score)

    plt.figure(figsize=(12, 6))
    bars = plt.barh(anime_names, average_scores, color='skyblue')
    plt.xlabel("Genre Similarity (%)")
    plt.title(f"📊 Genre Similarity Rata-rata untuk {sample_size} Anime")
    plt.gca().invert_yaxis()  # Anime terbaru di atas
    for bar, score in zip(bars, average_scores):
        plt.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2, f"{score}%", va='center')
    plt.tight_layout()
    plt.show()

batch_genre_similarity_plot(sample_size=10, top_k=5)