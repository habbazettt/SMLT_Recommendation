# -*- coding: utf-8 -*-
"""Submission_MLT_Hubbal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWJXRzh48u0sh1kG1U2iOqb80D1m_6aX

# Anime Recommendation System

## Data Collection

Import Library
"""

from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score
import re

"""Download Dataset"""

!pip install -q kaggle

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d bhavyadhingra00020/top-anime-dataset-2024

!unzip /content/top-anime-dataset-2024.zip

df = pd.read_csv('/content/Top_Anime_data.csv')

"""## Data Understanding"""

df.head()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

for i, (nama_kolom, jumlah) in enumerate(df.count().items(), 1):
    print(f"Kolom {i:2d}: {nama_kolom} - Berjumlah:  {jumlah}")

df.info()

"""### Ringkasan Struktur DataFrame

Terdapat total **22 kolom** dalam dataframe.
- Terdapat **1 kolom** dengan tipe data `float64`, yang merupakan fitur **numerik**:
  - `Score`
- Terdapat **3 kolom** dengan tipe data `int64`, yang juga merupakan fitur **numerik**:
  - `Popularity`, `Rank`, `Members`
- Terdapat **18 kolom** dengan tipe data `object`, yang kemungkinan besar merupakan fitur **kategoris**:
  - `Description`, `Synonyms`, `Japanese`, `English`, `Type`, `Episodes`, `Status`, `Aired`, `Premiered`, `Broadcast`, `Producers`, `Licensors`, `Studios`, `Source`, `Genres`, `Demographic`, `Duration`, `Rating`

**Pilihan Fitur untuk Content-Based Filtering**

Fitur utama yang digunakan:
- `Genres`: Merekomendasikan anime dengan genre serupa.
- `Type`: Membantu menyarankan tipe anime yang sama (TV, Movie, dll).
- `Studios`: Mengarahkan pada anime dengan gaya/kualitas serupa dari studio yang sama.

**Alasan**:  
Fitur-fitur ini cukup, relevan, dan efisien untuk membangun model rekomendasi yang akurat dan mudah diimplementasikan.
"""

df.duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""## Exploratory Data Analysis

### Deskripsi Variabel
"""

df.columns

"""**Penjelasan Kolom Dataframe**

Kolom datasets anime memiliki informasi berikut:

* **`Score`:** Skor atau rating yang diberikan kepada anime.
* **`Popularity`:** Peringkat popularitas anime.
* **`Rank`:** Peringkat anime berdasarkan kriteria tertentu.
* **`Members`:** Jumlah anggota yang telah menambahkan anime ke daftar mereka di platform.
* **`Description`:** Deskripsi singkat atau ringkasan plot anime.
* **`Synonyms`:** Judul alternatif atau sinonim dari anime.
* **`Japanese`:** Judul anime dalam bahasa Jepang.
* **`English`:** Judul anime dalam bahasa Inggris.
* **`Type`:** Jenis anime (misalnya, TV Series, Movie, OVA, dll.).
* **`Episodes`:** Jumlah episode dalam anime.
* **`Status`:** Status anime (misalnya, ongoing, completed).
* **`Aired`:** Tanggal penayangan anime.
* **`Premiered`:** Musim dan tahun penayangan perdana anime.
* **`Broadcast`:** Informasi tentang siaran anime.
* **`Producers`:** Perusahaan produksi atau produser anime.
* **`Licensors`:** Pihak yang memiliki lisensi anime (misalnya, platform streaming).
* **`Studios`:** Studio animasi yang mengerjakan anime.
* **`Source`:** Sumber materi anime (misalnya, manga, light novel, original).
* **`Genres`:** Genre anime, dipisahkan dengan koma (misalnya, Action, Comedy, Drama).
* **`Demographic`:** Demografi target anime (misalnya, Shonen, Shojo).
* **`Duration`:** Durasi setiap episode anime.
* **`Rating`:** Batasan usia untuk menonton anime.

### Visualisasi
"""

# Hitung jumlah anime untuk setiap kategori
ona = df.loc[df['Type'] == 'ONA'].shape[0]
tv = df.loc[df['Type'] == 'TV'].shape[0]
movie = df.loc[df['Type'] == 'Movie'].shape[0]
music = df.loc[df['Type'] == 'Music'].shape[0]
special = df.loc[df['Type'] == 'Special'].shape[0]
ova = df.loc[df['Type'] == 'OVA'].shape[0]

# Label dan warna untuk setiap kategori
labels = ['ONA', 'TV', 'Movie', 'Music', 'Special', 'OVA']
colors = ['#81F4E1', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B']

# Buat pie chart
plt.figure(figsize=(10, 7))
plt.title('Distribusi Kategori Anime')
plt.pie([ona, tv, movie, music, special, ova],
        labels=labels,
        colors=colors,
        autopct='%.2f%%',
        textprops={'color': 'black'})

plt.show()

plt.figure(figsize=(10, 6))
plt.hist(df['Score'],
         bins=20,
         color='#56CBF9',
         edgecolor='#0B4F6C',
         alpha=0.8)
plt.xlabel('Skor Anime', fontsize=12)
plt.ylabel('Jumlah Anime', fontsize=12)
plt.title('Distribusi Skor Anime (Skala 1-10)', fontsize=14, pad=20)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

df.describe().T

df.sort_values(by='Members', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Members']].sort_values(by='Members', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B', '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Members'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Jumlah Members", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

df.sort_values(by='Score', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Score']].sort_values(by='Score', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B',
          '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Score'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Skor", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

"""## Data Preparation"""

def clean_anime_title(text):
    if pd.isna(text):  # Handle missing values
        return ""

    # Hapus URL
    text = re.sub(r"https?://\S+|www\.\S+", "", text)

    # Hapus karakter non-alfanumerik kecuali apostrof, tanda hubung, dan spasi
    text = re.sub(r"[^a-zA-Z0-9'\- ]", "", text)

    # Hapus spasi berlebih
    text = re.sub(r"\s+", " ", text).strip()

    return text
# Eksekusi pembersihan dan buat kolom baru
df['English_clean'] = df['English'].apply(clean_anime_title)

def clean_genres(genre_text):
    if pd.isna(genre_text):
        return ""

    raw_genres = genre_text.split(',')
    cleaned_genres = set()

    for genre in raw_genres:
        genre = genre.strip()
        half = len(genre) // 2

        if len(genre) % 2 == 0 and genre[:half].lower() == genre[half:].lower():
            genre = genre[:half]

        cleaned_genres.add(genre.lower())

    return ", ".join(sorted(cleaned_genres))  # sorted biar konsisten

df['Genres_clean'] = df['Genres'].apply(clean_genres)

def clean_studios(studio_str):
    if pd.isna(studio_str):
        return ""

    studios = [s.strip().lower() for s in studio_str.split(",") if s.strip()]
    return ", ".join(sorted(set(studios)))

df["Studios_clean"] = df["Studios"].apply(clean_studios)

print("Before:", df['Genres'].iloc[0])
print("After:", df['Genres_clean'].iloc[0])

print("Before:", df['English'].iloc[0])
print("After:", df['English_clean'].iloc[0])

print("Before:", df['Studios'].iloc[0])
print("After:", df['Studios_clean'].iloc[0])

print(df[['English', 'English_clean']].sample(3))
print(df[['Genres', 'Genres_clean']].sample(3))
print(df[['Studios', 'Studios_clean']].sample(3))

"""Membersihkan judul anime dengan:
1. Menghapus URL (jika ada).
2. Menghapus karakter khusus kecuali apostrof (`'`), tanda hubung (`-`), dan spasi.
3. Menghapus spasi berlebih.
"""

df

df.astype(str).duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""Terdapat *Missing value* pada kolom `sypnopsis, Japanese, English, Premiered, Broadcast, Genres dan Demographic`"""

df = df.dropna()

"""Menghapus data *Missing value*"""

df.isnull().sum()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

df.describe().T

"""Fungsi `describe()` memberikan informasi statistik pada masing-masing kolom, antara lain:

- `Count` adalah jumlah sampel pada data.
- `Mean` adalah nilai rata-rata.
- `Std` adalah standar deviasi.
- `Min` yaitu nilai minimum setiap kolom.
- `25%` adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
- `50%` adalah kuartil kedua, atau biasa juga disebut median (nilai tengah). - 75% adalah kuartil ketiga.
- `Max` adalah nilai maksimum.

## Model Development
"""

df

data = df.drop(columns=[
    'Score',
    'Popularity',
    'Rank',
    'Members',
    'Description',
    'Synonyms',
    'Japanese',
    'English',
    'Genres',
    'Episodes',
    'Status',
    'Aired',
    'Premiered',
    'Broadcast',
    'Producers',
    'Licensors',
    'Source',
    'Duration',
    'Demographic'
])

"""Mengahapus kolom yang tidak dibutuhkan pada model kali ini."""

data

"""### Model Content Based Filtering (dengan Filter Genres)"""

tfid = TfidfVectorizer()
tfid.fit(data['Genres_clean'])

tfid.get_feature_names_out()

tfidf_matrix = tfid.fit_transform(data['Genres_clean'])

tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfid.get_feature_names_out(),
    index=data.Genres_clean
).sample(22, axis=1).sample(10, axis=0)

"""Output `matriks tf-idf` di atas menunjukkan hubungan antara nama anime terhadap kategori yang dipilih. Matriks ini menunjukkan seberapa besar korelasi antara Anime terhadap kategori yang dipilih."""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(cosine_sim, index=data['English_clean'], columns=data['English_clean'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(5, axis=0)

def anime_recommendations(anime_name, similarity_data=cosine_sim_df, items=data[['English_clean','Genres_clean']], k=5):

    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

data[data.English_clean.eq('One Piece')]

anime_recommendations('One Piece')

"""Sistem telah berhasil merekomendasikan top 5 persen anime yang mirip dengan *One Piece*, yaitu beberapa film dan seri dari *One Piece* itu sendiri. Jadi, jika pengguna menyukai *One Piece*, maka sistem dapat merekomendasikan seri atau movie *One Piece* lainnya.

### Model K-Nearest Neighbor
"""

animedf_name = pd.DataFrame({'English_clean': data['English_clean']})
animedf_name.head()

data.set_index('English_clean',inplace=True)

data_n = data[['Genres_clean', 'Type', 'Studios']]

data_features = pd.get_dummies(data_n[['Type', 'Studios']])
data_features.index = data.index

model = NearestNeighbors(metric='euclidean')
model.fit(data_features)

def Recommended_model(anime_name: str, recommend_anime: int = 5):
    if anime_name not in data_features.index:
        return f"❌ Anime '{anime_name}' tidak ditemukan dalam data."

    print(f"✅ Apabila pengguna menyukai anime: {anime_name}")
    print(f"📌 Berikut ini adalah {recommend_anime} anime yang mungkin juga disukai:")

    # Cari tetangga terdekat
    distances, neighbors = model.kneighbors(
        data_features.loc[[anime_name]], n_neighbors=recommend_anime + 1
    )

    similar_anime = []
    similar_distance = []

    for idx, distance in zip(neighbors[0][1:], distances[0][1:]):  # skip self
        similar_anime.append(data_features.index[idx])
        similar_distance.append(f"{round(100 - distance, 2)}%")

    return pd.DataFrame({
        "Anime Name": similar_anime,
        "Similarity Score": similar_distance
    })

Recommended_model(animedf_name.iloc[21]['English_clean'])

"""## Evaluation"""

def evaluate_recommendation(anime_name: str, top_n: int = 5):
    recommendations = Recommended_model(anime_name, recommend_anime=top_n)

    if isinstance(recommendations, str):
        return recommendations

    original_genres = set(str(data.loc[anime_name, 'Genres_clean']).lower().split())

    genre_matches = []
    for rec_name in recommendations['Anime Name']:
        rec_genres = set(str(data.loc[rec_name, 'Genres_clean']).lower().split())
        intersection = original_genres & rec_genres
        similarity_score = len(intersection) / len(original_genres) if original_genres else 0
        genre_matches.append(f"{round(similarity_score * 100, 2)}%")

    recommendations['Genre Similarity'] = genre_matches
    return recommendations

evaluate_recommendation("Gintama", top_n=10)