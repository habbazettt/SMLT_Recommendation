# -*- coding: utf-8 -*-
"""Submission_MLT_Hubbal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWJXRzh48u0sh1kG1U2iOqb80D1m_6aX

# Anime Recommendation System

## Data Collection

Import Library
"""

from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import precision_score, recall_score, f1_score
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score
from scipy.sparse import hstack
import re
from sklearn.preprocessing import StandardScaler

"""Download Dataset"""

!pip install -q kaggle

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d bhavyadhingra00020/top-anime-dataset-2024

!unzip /content/top-anime-dataset-2024.zip

df = pd.read_csv('/content/Top_Anime_data.csv')

"""## Data Understanding"""

df.head()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

for i, (nama_kolom, jumlah) in enumerate(df.count().items(), 1):
    print(f"Kolom {i:2d}: {nama_kolom} - Berjumlah:  {jumlah}")

df.info()

"""### Ringkasan Struktur DataFrame

Terdapat total **22 kolom** dalam dataframe.
- Terdapat **1 kolom** dengan tipe data `float64`, yang merupakan fitur **numerik**:
  - `Score`
- Terdapat **3 kolom** dengan tipe data `int64`, yang juga merupakan fitur **numerik**:
  - `Popularity`, `Rank`, `Members`
- Terdapat **18 kolom** dengan tipe data `object`, yang kemungkinan besar merupakan fitur **kategoris**:
  - `Description`, `Synonyms`, `Japanese`, `English`, `Type`, `Episodes`, `Status`, `Aired`, `Premiered`, `Broadcast`, `Producers`, `Licensors`, `Studios`, `Source`, `Genres`, `Demographic`, `Duration`, `Rating`

**Pilihan Fitur untuk Content-Based Filtering**

Fitur utama yang digunakan:
- `Genres`: Merekomendasikan anime dengan genre serupa.
- `Type`: Membantu menyarankan tipe anime yang sama (TV, Movie, dll).
- `Studios`: Mengarahkan pada anime dengan gaya/kualitas serupa dari studio yang sama.

**Alasan**:  
Fitur-fitur ini cukup, relevan, dan efisien untuk membangun model rekomendasi yang akurat dan mudah diimplementasikan.
"""

df.duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""## Exploratory Data Analysis

### Deskripsi Variabel
"""

df.columns

"""**Penjelasan Kolom Dataframe**

Kolom datasets anime memiliki informasi berikut:

* **`Score`:** Skor atau rating yang diberikan kepada anime.
* **`Popularity`:** Peringkat popularitas anime.
* **`Rank`:** Peringkat anime berdasarkan kriteria tertentu.
* **`Members`:** Jumlah anggota yang telah menambahkan anime ke daftar mereka di platform.
* **`Description`:** Deskripsi singkat atau ringkasan plot anime.
* **`Synonyms`:** Judul alternatif atau sinonim dari anime.
* **`Japanese`:** Judul anime dalam bahasa Jepang.
* **`English`:** Judul anime dalam bahasa Inggris.
* **`Type`:** Jenis anime (misalnya, TV Series, Movie, OVA, dll.).
* **`Episodes`:** Jumlah episode dalam anime.
* **`Status`:** Status anime (misalnya, ongoing, completed).
* **`Aired`:** Tanggal penayangan anime.
* **`Premiered`:** Musim dan tahun penayangan perdana anime.
* **`Broadcast`:** Informasi tentang siaran anime.
* **`Producers`:** Perusahaan produksi atau produser anime.
* **`Licensors`:** Pihak yang memiliki lisensi anime (misalnya, platform streaming).
* **`Studios`:** Studio animasi yang mengerjakan anime.
* **`Source`:** Sumber materi anime (misalnya, manga, light novel, original).
* **`Genres`:** Genre anime, dipisahkan dengan koma (misalnya, Action, Comedy, Drama).
* **`Demographic`:** Demografi target anime (misalnya, Shonen, Shojo).
* **`Duration`:** Durasi setiap episode anime.
* **`Rating`:** Batasan usia untuk menonton anime.

### Visualisasi
"""

ona = df.loc[df['Type'] == 'ONA'].shape[0]
tv = df.loc[df['Type'] == 'TV'].shape[0]
movie = df.loc[df['Type'] == 'Movie'].shape[0]
music = df.loc[df['Type'] == 'Music'].shape[0]
special = df.loc[df['Type'] == 'Special'].shape[0]
ova = df.loc[df['Type'] == 'OVA'].shape[0]

labels = ['ONA', 'TV', 'Movie', 'Music', 'Special', 'OVA']
colors = ['#81F4E1', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B']

plt.figure(figsize=(10, 7))
plt.title('Distribusi Kategori Anime')
plt.pie([ona, tv, movie, music, special, ova],
        labels=labels,
        colors=colors,
        autopct='%.2f%%',
        textprops={'color': 'black'})

plt.show()

plt.figure(figsize=(10, 6))
plt.hist(df['Score'],
         bins=20,
         color='#56CBF9',
         edgecolor='#0B4F6C',
         alpha=0.8)
plt.xlabel('Skor Anime', fontsize=12)
plt.ylabel('Jumlah Anime', fontsize=12)
plt.title('Distribusi Skor Anime (Skala 1-10)', fontsize=14, pad=20)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

df.describe().T

df.sort_values(by='Members', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Members']].sort_values(by='Members', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B', '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Members'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Jumlah Members", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

df.sort_values(by='Score', ascending=False).head()

plt.figure(figsize=(20, 15))
top10_anime = df[['English', 'Score']].sort_values(by='Score', ascending=False).head(10)

colors = ['#87255B', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B',
          '#D3C4D1', '#81F4E1', '#C2AFF0', '#C57B57']

labels = top10_anime['English'].values.flatten()
values = top10_anime['Score'].values.flatten()

plt.barh(labels, values, color=colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.title("Top 10 Anime Berdasarkan Skor", fontdict={'fontsize': 20})
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x='Score', y='Members', data=df, alpha=0.6, color='#87255B')
plt.title('Skor vs. Popularitas', fontsize=14)
plt.xlabel('Skor', fontsize=12)
plt.ylabel('Jumlah Members', fontsize=12)
plt.show()

# Ekstrak durasi dalam menit (contoh: '24 min per ep' -> 24)
df['Duration_min'] = df['Duration'].str.extract('(\d+)').astype(float)

plt.figure(figsize=(10, 6))
sns.boxplot(x='Duration_min', data=df, color='#81F4E1')
plt.title('Distribusi Durasi Episode', fontsize=14)
plt.xlabel('Durasi (menit)', fontsize=12)
plt.show()

top_studios = df['Studios'].value_counts().head(10)

plt.figure(figsize=(12, 6))
top_studios.plot(kind='bar', color='#C57B57')
plt.title('Top 10 Studio Anime Berdasarkan Jumlah Produksi', fontsize=14)
plt.xlabel('Studio', fontsize=12)
plt.ylabel('Jumlah Anime', fontsize=12)
plt.xticks(rotation=45)
plt.show()

# Hitung frekuensi genre
all_genres = df['Genres'].str.split(', ').explode()
genre_counts = all_genres.value_counts().head(10)

# Plot
plt.figure(figsize=(12, 6))
genre_counts.plot(kind='barh', color='#C57B57')
plt.title('Top 10 Genre Anime', fontsize=14)
plt.xlabel('Jumlah Anime')
plt.gca().invert_yaxis()
plt.show()

"""## Data Preparation"""

def clean_anime_title(text):
    if pd.isna(text):
        return ""
    text = re.sub(r"https?://\S+|www\.\S+", "", text)  # hapus URL
    text = re.sub(r"[^a-zA-Z0-9'\- ]", "", text)       # hapus karakter non-alfanumerik kecuali tanda kutip dan tanda hubung
    text = re.sub(r"\s+", " ", text).strip()           # normalisasi spasi
    return text

df['English'] = df['English'].apply(clean_anime_title)

def clean_genres(genre_text):
    if pd.isna(genre_text):
        return ""
    raw_genres = genre_text.split(',')
    cleaned_genres = set()
    for genre in raw_genres:
        genre = genre.strip()
        half = len(genre) // 2
        if len(genre) % 2 == 0 and genre[:half].lower() == genre[half:].lower():
            genre = genre[:half]  # deteksi pengulangan
        cleaned_genres.add(genre.lower())
    return ", ".join(sorted(cleaned_genres))

df['Genres'] = df['Genres'].apply(clean_genres)

def clean_studios(studio_str):
    if pd.isna(studio_str):
        return ""
    studios = [s.strip().lower() for s in studio_str.split(",") if s.strip()]
    return ", ".join(sorted(set(studios)))

df['Studios'] = df['Studios'].apply(clean_studios)

df

df.astype(str).duplicated().sum()

"""Tidak terdapat data duplikat"""

df.isnull().sum()

"""Terdapat *Missing value* pada kolom `sypnopsis, Japanese, English, Premiered, Broadcast, Genres dan Demographic`"""

df.dropna()

"""Menghapus data *Missing value*"""

df.isnull().sum()

print(f'Terdapat  {df.shape[0]} Table dan {df.shape[1]} columns.')

df.describe().T

"""Fungsi `describe()` memberikan informasi statistik pada masing-masing kolom, antara lain:

- `Count` adalah jumlah sampel pada data.
- `Mean` adalah nilai rata-rata.
- `Std` adalah standar deviasi.
- `Min` yaitu nilai minimum setiap kolom.
- `25%` adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
- `50%` adalah kuartil kedua, atau biasa juga disebut median (nilai tengah). - 75% adalah kuartil ketiga.
- `Max` adalah nilai maksimum.
"""

# Convert numerical columns to numeric
df['Episodes'] = pd.to_numeric(df['Episodes'], errors='coerce')
df['Episodes'] = df['Episodes'].fillna(df['Episodes'].median())

# One-Hot Encoding for categorical features
categorical_cols = ['Type', 'Status', 'Source', 'Rating']
df_encoded = pd.get_dummies(df[categorical_cols], drop_first=True)

# Prepare numerical features
numeric_features = df[['Score', 'Members', 'Popularity', 'Rank', 'Episodes']]
scaler = StandardScaler()
scaled_numeric = scaler.fit_transform(numeric_features)

# Feature Extraction with TF-IDF
tfidf_title = TfidfVectorizer(max_features=300)
title_tfidf = tfidf_title.fit_transform(df['English'])
tfidf_genre = TfidfVectorizer(max_features=100)
genre_tfidf = tfidf_genre.fit_transform(df['Genres'])
tfidf_studio = TfidfVectorizer(max_features=50)
studio_tfidf = tfidf_studio.fit_transform(df['Studios'])

# Combine TF-IDF features
tfidf_features = hstack([title_tfidf, genre_tfidf, studio_tfidf])

# Combine all features
all_features = hstack([tfidf_features, scaled_numeric])

"""## Model Development

### Model Cosine Similarity Recommendation
"""

# Hitung matriks similaritas
cosine_sim = cosine_similarity(all_features, dense_output=False)

def cosine_recommender(anime_index, n_recommend=5):
    # Dapatkan skor similaritas untuk anime target
    sim_scores = list(enumerate(cosine_sim[anime_index].toarray().flatten()))

    # Urutkan berdasarkan skor tertinggi
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Ambil n_recommend + 1 (karena termasuk diri sendiri)
    sim_scores = sim_scores[1:n_recommend+1]  # Exclude itself

    # Dapatkan indeks anime yang direkomendasikan
    anime_indices = [i[0] for i in sim_scores]

    # Return dataframe rekomendasi
    recommendations = df.iloc[anime_indices][['English', 'Score', 'Genres', 'Type', 'Studios']]
    recommendations['Similarity Score'] = [i[1] for i in sim_scores]

    return recommendations

cosine_recommender(anime_index = 10, n_recommend=5)

"""### Model KNN"""

# Bangun model KNN dengan metrik cosine
knn_model = NearestNeighbors(
    n_neighbors=6,
    metric='cosine',
    algorithm='brute'
)

# Latih model dengan data features gabungan
knn_model.fit(all_features)

def knn_recommender(anime_index, n_recommend=5):
    # Mengonversi sparse matrix ke array
    all_features_array = all_features.toarray()

    # Dapatkan query (anime target)
    query = all_features_array[anime_index].reshape(1, -1)  # Mengubah bentuk menjadi 2D

    # Cari anime terdekat
    distances, indices = knn_model.kneighbors(query, n_neighbors=n_recommend+1)

    # Exclude diri sendiri
    indices = indices.flatten()[1:]
    distances = distances.flatten()[1:]

    # Return dataframe rekomendasi
    recommendations = df.iloc[indices][['English', 'Score', 'Genres', 'Type', 'Studios']]
    recommendations['Distance Score'] = 1 - distances  # Convert ke similarity score

    return recommendations

knn_recommender(anime_index = 10, n_recommend=5)

"""## Evaluation"""

def evaluate_recommendations(true_recommendations, predicted_recommendations):
    # Mengonversi ke set untuk perbandingan
    true_set = set(true_recommendations)
    predicted_set = set(predicted_recommendations)

    # Hitung True Positives, False Positives, dan False Negatives
    true_positives = len(true_set.intersection(predicted_set))
    false_positives = len(predicted_set - true_set)
    false_negatives = len(true_set - predicted_set)

    # Hitung Precision, Recall, dan F1 Score
    precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
    recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0
    f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

    return {
        'Precision': precision,
        'Recall': recall,
        'F1 Score': f1
    }

# Ambil anime target berdasarkan indeks
target_index = 0
anime_target = df.iloc[target_index][['English', 'Score', 'Genres', 'Type', 'Studios']]

# Cetak informasi anime target
print("🎯 Anime Target:")
print("-"*50)
print(f"Judul: {anime_target['English']}")
print(f"Genre: {anime_target['Genres']}")
print(f"Studio: {anime_target['Studios']}")
print(f"Tipe: {anime_target['Type']}")
print(f"Skor: {anime_target['Score']}\n")

# Ambil rekomendasi dari kedua model
cosine_recommendations = cosine_recommender(target_index)['English'].tolist()
knn_recommendations = knn_recommender(target_index)['English'].tolist()

# Cetak rekomendasi yang dihasilkan
print("Rekomendasi Cosine Similarity:", cosine_recommendations)
print("Rekomendasi KNN:", knn_recommendations)

# Contoh ground truth yang diperbarui
true_recommendations = ['Bleach Thousand-Year Blood War', 'Fighting Spirit', 'Gintama Season 4', 'Gintama Season 2', 'Odd Taxi']

# Cetak ground truth
print("Ground Truth:", true_recommendations)

# Evaluasi rekomendasi
cosine_evaluation_results = evaluate_recommendations(true_recommendations, cosine_recommendations)
knn_evaluation_results = evaluate_recommendations(true_recommendations, knn_recommendations)

# Cetak hasil evaluasi
print("\n📊 Hasil Evaluasi Rekomendasi Cosine Similarity 📊")
print(f"Precision: {cosine_evaluation_results['Precision']:.2f}")
print(f"Recall: {cosine_evaluation_results['Recall']:.2f}")
print(f"F1 Score: {cosine_evaluation_results['F1 Score']:.2f}")

print("\n📊 Hasil Evaluasi Rekomendasi KNN 📊")
print(f"Precision: {knn_evaluation_results['Precision']:.2f}")
print(f"Recall: {knn_evaluation_results['Recall']:.2f}")
print(f"F1 Score: {knn_evaluation_results['F1 Score']:.2f}")